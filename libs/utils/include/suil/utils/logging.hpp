/**
 * Copyright (c) 2022 Suilteam, Carter Mbotho
 *
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the MIT license. See LICENSE for details.
 * 
 * @author Carter
 * @date 2022-03-12
 */

#pragma once

#include <suil/utils/utils.hpp>
#include <suil/utils/symbols.hpp>

#include <cstdarg>
#include <functional>
#include <memory>

#ifndef SUIL_LOG_BUFFER_SIZE
#define SUIL_LOG_BUFFER_SIZE 2048
#endif

namespace suil {

#if SUIL_ENABLE_BACKTRACE==1
    /**
         * capture the current backtrace into the given buffer
         * @param buf the buffer to dump the stack trace into
         * @size the size of the buffer
         */
        void backtrace(char *buf, size_t size);
#else
#define  backtrace(buf, size)
#endif

    /**
     * an enum of supported log levels
     */
    typedef enum : unsigned char {
        TRACE,
        DEBUG,
        INFO,
        NOTICE,
        WARNING,
        ERROR,
        CRITICAL
    } Level;

    /**
     * The default log formatter. Log formatters can be changed
     * to change the output style of the log
     * @see \def LogFormat
     */
    struct DefaultFormatter {
        size_t operator()(char *out,
                          Level l,
                          const char *tag,
                          const char *fmt,
                          va_list args);
        size_t format(
                char *out,
                Level l,
                const char *tag,
                const char *fmt,
                ...);
    };

    /**
     * Log formatter template
     * @param out formatter shuld format into this buffer, it size is always 2048_B
     * @param l the log level that produced this log
     * @param tag the logging tag that produced the log
     * @param fmt c-style printf format string
     * @param args variable arguments list
     *
     * @return must return the number of bytes written into the buffer
     */
    using LogFormat = std::function<size_t(char *out, Level l, const char *tag, const char *fmt, va_list args)>;

    /**
     * default log sink accepts the formatted log message and prints it to console
     * color coded
     */
    struct DefaultWriter {
        void operator()(const char *log, size_t, Level);
    };

    class LogWriter {
    public:
        sptr(LogWriter);

        virtual void write(const char *log,
                           size_t size,
                           Level level,
                           const char* tag);
    };

    /**
     * define a log tag which can be attached to a class
     * @param the name that will be used to tag log messages generated by the
     * class tagged with this tag
     */
#define define_log_tag(name) \
        struct name##_log_tag {\
            static constexpr char *TAG = (char *)#name; \
        }
    /**
     * get the fully qualified name of the tag
     * @param name
     */
#define dtag(name)   name##_log_tag

    define_log_tag(SYSTEM);

    template<class T = dtag(SYSTEM)>
    struct Logger {
        Logger() {}

        Logger(const char *tag)
                : tag(::strdup(tag)) {}

        void log(Level l, const char *fmt, ...) const;

        virtual ~Logger() {
            if (tag) {
                free(tag);
                tag = nullptr;
            }
        }

    private:
        char *tag{nullptr};
    };

    struct _Logger : public Logger<> {

        _Logger();

        Level getLevel() const;

        bool isValid() const;

        void forwardLogs(const char *log, size_t sz, Level l, const char* tag);

        size_t format(char *out, Level l, const char *tag, const char *fmt, va_list args);

        const char *name() const {
            return _name.c_str();
        }

        template<li::is_variable T, typename... Opts>
        void setup(T&& opt, Opts&&... opts) {
            setup(std::forward<T>(opt));
            if constexpr (sizeof...(opts) > 0) {
                setup(std::forward<Opts>(opts)...);
            }
        }

        void setup(Var(verbose, Level) var) {
            auto l = li::symbol_member_access(var, s::verbose);
            if (l >= TRACE && l <= Level::CRITICAL) {
                /* set log level */
                Ego._lvl = (Level) l;
            }
        }

        void setup(Var(format, LogFormat) var) {
            auto fmt = li::symbol_member_access(var, s::format);
            if (fmt != nullptr) {
                /* set log formatter */
                Ego._formatter = std::move(fmt);
            }
        }

        void setup(Var(writer, LogWriter::Ptr) var) {
            auto writer = li::symbol_member_access(var, s::writer);
            if (writer != nullptr) {
                Ego._writer = std::move(writer);
            }
        }

        void setup(Var(name, std::string) var) {
            auto name = li::symbol_member_access(var, s::name);
            if (!name.empty()) {
                Ego._name = name;
            }
        }

        template<typename  T, typename... Args>
        requires std::is_base_of_v<LogWriter, T>
        void use(Args... args) {
            _writer = std::make_unique<LogWriter>(std::forward<Args>(args)...);
        }

        void reset();

    private:
        LogWriter::Ptr _writer{nullptr};
        Level _lvl{DEBUG};
        LogFormat _formatter{nullptr};
        std::string _name{};
    };

    extern _Logger& _Log;

    template<typename T>
    void Logger<T>::log(Level l, const char *fmt, ...) const {
        if (!_Log.isValid()) {
            return;
        }

        char buf[SUIL_LOG_BUFFER_SIZE];
        va_list args;
        va_start(args, fmt);
        size_t sz = _Log.format(buf, l, T::TAG, fmt, args);
        va_end(args);

        if (sz > 0) {
            // forward logs to their destination
            _Log.forwardLogs(buf, sz, l, T::TAG);
        }

        if (l == Level::CRITICAL) {
            backtrace(buf, SUIL_LOG_BUFFER_SIZE);
        }
    }

    /**
     * configure the logger with different options
     * @tparam Opts option types, deduced
     * @param opts list of options in form opt(name, value),...
     *
     * @note the following are the supported options and are all optional
     * @code
     * opt(verbose, Level) -    // the accepted logging verbosity
     * opt(format,  LogFormat)  // a formatting callback function
     * opt(sink,    LogSink)    // the logging, where all logs are sent
     * opt(name,    const char) // the name of the logging application
     * @endcode
     */
    template<typename... Opts>
    inline static void setup(Opts... opts) {
        _Log.setup(std::forward<Opts>(opts)...);
    }

    class Syslog : public LogWriter {
    public:
        sptr(Syslog);
        Syslog(const char *name = "suil");

        void write(const char *msg, size_t sz, Level lvl, const char *tag) override;

        void close();

        inline ~Syslog() {
            Ego.close();
        }
    };
}

/**
 * used to attach a logger to a class by inheriting the tag
 * @example
 * @code
 *
 * define_log_tag(HTTP);
 *
 * struct Connection: LOGGER(HTTP) {
 *    ...
 * };
 *
 * @endcode
 */
#define LOGGER(tag) suil::Logger<dtag(tag)>

#define _LOG(sub, l, fmt, ...)                                 \
    if (suil::_Log.getLevel() <= (suil::Level:: l))       \
        (sub)->log(suil::Level:: l , fmt , ##__VA_ARGS__)

/**
 * log a debug message using the given logging class \param sub
 * @param sub
 * @param fmt
 * @param ...
 */
#define ldebug(sub, fmt, ...)    _LOG(sub, DEBUG, fmt, ##__VA_ARGS__)
/**
 * log a debug message using current class tag (must have a tag attached)
 * @param fmt
 * @param ...
 */
#define idebug(fmt, ...)         _LOG(this, DEBUG, fmt, ##__VA_ARGS__)
/**
 * log a debug message using system tag (SYSTEM)
 * @param fmt
 * @param ...
 */
#define sdebug(fmt, ...)         _LOG(&suil::_Log, DEBUG, fmt, ##__VA_ARGS__)
/**
 * log a warning message using the given logging class \param sub
 * @param sub
 * @param fmt
 * @param ...
 */
#define lwarn(sub, fmt, ...)     _LOG(sub, WARNING, fmt, ##__VA_ARGS__)
/**
 * log a warning message using current class tag (must have a tag attached)
 * @param fmt
 * @param ...
 */
#define iwarn(fmt, ...)           _LOG(this, WARNING, fmt, ##__VA_ARGS__)
/**
 * log a warning message using system tag (SYSTEM)
 * @param fmt
 * @param ...
 */
#define swarn(fmt, ...)          _LOG(&suil::_Log, WARNING, fmt, ##__VA_ARGS__)
/**
 * log a info message using the given logging class \param sub
 * @param sub
 * @param fmt
 * @param ...
 */
#define linfo(sub, fmt, ...)     _LOG(sub, INFO, fmt, ##__VA_ARGS__)
/**
 * log a info message using current class tag (must have a tag attached)
 * @param fmt
 * @param ...
 */
#define iinfo(fmt, ...)           _LOG(this, INFO, fmt, ##__VA_ARGS__)
/**
 * log a info message using system tag (SYSTEM)
 * @param fmt
 * @param ...
 */
#define sinfo(fmt, ...)          _LOG(&suil::_Log, INFO, fmt, ##__VA_ARGS__)
/**
 * log a notice message using the given logging class \param sub
 * @param sub
 * @param fmt
 * @param ...
 */
#define lnotice(sub, fmt, ...)   _LOG(sub, NOTICE, fmt, ##__VA_ARGS__)
/**
 * log a notice message using current class tag (must have a tag attached)
 * @param fmt
 * @param ...
 */
#define inotice(fmt, ...)         _LOG(this, NOTICE, fmt, ##__VA_ARGS__)
/**
 * log a notice message using system tag (SYSTEM)
 * @param fmt
 * @param ...
 */
#define snotice(fmt, ...)        _LOG(&suil::_Log, NOTICE, fmt, ##__VA_ARGS__)
/**
 * log a error message using the given logging class \param sub
 * @param sub
 * @param fmt
 * @param ...
 */
#define lerror(sub, fmt, ...)    _LOG(sub, ERROR, fmt, ##__VA_ARGS__)
/**
 * log a error message using current class tag (must have a tag attached)
 * @param fmt
 * @param ...
 */
#define ierror(fmt, ...)          _LOG(this, ERROR, fmt, ##__VA_ARGS__)
/**
 * log a error message using system tag (SYSTEM)
 * @param fmt
 * @param ...
 */
#define serror(fmt, ...)         _LOG(&suil::_Log, ERROR, fmt, ##__VA_ARGS__)
/**
 * log a critical message using the given logging class \param sub
 * @param sub
 * @param fmt
 * @param ...
 */
#define lcritical(sub, fmt, ...) _LOG(sub, CRITICAL, fmt, ##__VA_ARGS__)
/**
 * log a critical message using current class tag (must have a tag attached)
 * @param fmt
 * @param ...
 */
#define icritical(fmt, ...)       _LOG(this, CRITICAL, fmt, ##__VA_ARGS__)
/**
 * log a critical message using system tag (SYSTEM)
 * @param fmt
 * @param ...
 */
#define scritical(fmt, ...)      _LOG(&suil::_Log, CRITICAL, fmt, ##__VA_ARGS__)

#if SUIL_ENABLE_TRACE==1
/**
 * log a trace message using the given logging class \param sub
 * @param sub
 * @param fmt
 * @param ...
 */
#define ltrace(l, fmt, ...)                                           \
    if (suil::_Log.getLevel() <= suil::Level::TRACE)                   \
        (l)->log(suil::Level::TRACE, "%s:%d " fmt, __FILE__,     \
                    __LINE__, ##__VA_ARGS__)
/**
 * log a trace message using current class tag (must have a tag attached)
 * @param fmt
 * @param ...
 */
#define itrace(fmt, ...)  ltrace(this, fmt, ##__VA_ARGS__)
/**
 * log a trace message using system tag (SYSTEM)
 * @param fmt
 * @param ...
 */
#define strace(fmt, ...) ltrace(&suil::_Log, fmt, ##__VA_ARGS__)

#else

#define ltrace(l, fmt, ...)
#define itrace(fmt, ...)
#define strace(fmt, ...)

#endif
